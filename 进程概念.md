```
ps：提供了进程的一次性的查看，它提供的查看结果并不是动态连续的。
	ps aux：显示所有的进程
	ps -l：将目前属于您自己这次登入的PID与相关信息列示出來(只与自己的bash有关)
grep：是一种强大的文本搜索工具，全面搜索正则表达式并把匹配的行打印出来
top：打开Linux下的任务管理器指令（对进程时间监控）            q退出
```

/proc：proc文件系统，在Linux中有额外的机制可以为内核和内核模块将信息发送给进程-- /proc 文件系统。最初设计的目的是允许更方便的对进程信息进行访问

cwd：当前进程的工作目录

exe：当前进程对应的可执行文件的目录

```
进程控制kill：向目标进程发信号           

        kill -l：查寻可以给进程发的信号的指令
        kill -9 PID：终止进程
        kill -19 PID：暂停进程
```

./test &：把test这个程序放在后台执行



​	并发：在一个CPU下多个进程进行切换，在一个时间段内，多个任务都得到推进叫做并发。

​	并行：在多CPU体系下，在一个时刻下，多个进程都在运行的情况叫做并行。

​	IO密集型：（I/O bound）:任务大量进行对I/O设备（硬盘/内存）进行读写操作。

​	CPU密集型：（CPU bound）:任务大量要求CPU进行计算、逻辑判断等功能，对CPU占有率高。

计算机存储器：1.内部存储器（内存）：易失性存储介质，速度快

​                           2.外部存储器（主要是磁盘）

​                                                   1》硬盘：永久性存储介质

​                                                   2》软盘：

编译好的程序是在计算机硬盘上存在的一个二进制文件。

##### 冯·诺依曼体系结构

CPU集成俩个硬件，运算器和控制器。

输入或者输出设备，统称为外设。

这里的存储器指的是内存。

在数据层面上，CPU只能对内存进行读写，不能访问外设。

处理速度：CPU>>内存>>外设

离CPU越近的存储介质速度越快，离CPU越远的存储介质速度越慢。

寄存器----》缓存----》内存----》硬盘----》网盘

所有设备只能直接和内存打交道。



为什么硬盘上的程序文件要被加载到内存去运行？

答：CPU不能直接和硬盘接触，只能去内存中读取数据。

#### 操作系统Operator System(OS)

###### 任何计算机系统都包含一个基本的程序集合，称为操作系统。

操作系统搭建在一堆硬件上，对硬件进行调度管理协调，然后让硬件跑起来。

但是操作系统和硬件之间并不是直接管理的关系，中间还有一套驱动，驱动一般都是对应的厂商提供的。

1.内核（进程管理、内存管理、文件管理、驱动管理）

2.外壳（函数库、shell）

###### 设计OS目的

与硬件交互，管理所有的软硬件资源；为用户程序提供一个良好的执行环境。

###### 系统调用和库函数

操作系统会对外会表现为一个整体，但是会暴露自己的部分接口，让用户使用，这部分由操作系统提供的接口，叫做系统调用。

系统调用在使用上，对用户要求比较高，所以有的开发者对系统调用就行了封装，从而形成了第三方库。

#### 进程

进程包含代码、数据、PCB、虚拟地址空间、页表

进程是程序的一个执行实例，正在执行的程序。担当分配系统资源（CPU时间，内存）的实体。

###### 描述进程PCB

进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合，称为PCB，Linux下的PCB：task_struct。PCB包含了目标进程的所有信息。

task_struct是PCB的一种，是Linux内核的一种数据结构，它会被装载到RAM（内存）里并包含着进程的信息。

task_struct内容分类：

标识符PID：描述本进程的唯一标识符，用来区别其他进程。类似于学号

状态：任务状态，退出代码，退出信号

​          r状态    s状态

​          在系统中，r状态仅仅表明该进程允许被放在CPU里去运行

​          再搞一条链表，只放r状态的进程的PCB，按优先级排好，叫做调度队列

优先级：相对于其他进程的优先级。系统进程数目众多，而CPU资源只有少量甚至一个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理竞争相关资源，便具有了优先级。

程序计数器： 保存了将要取出的下一条指令的内存地址。在指令取出之后，程序计数器就被更新以便指向后继的指令。

​		计算机怎么知道代码执行到哪一步呢？

 		CPU寄存器当中包括了一个重要的寄存器（PC指针：保存着当前正在执行指令的下一条指令的地址），也就是这里的程序计数器。所以CPU要读取指令时，找PC指针，拿着PC指针里面的地址去找，读取了指令后，这个PC指针默认地址向下移。

​                时间片：任何一个进程只要在CPU上运行，超过一定的时间范围后，强制从CPU上剥离下来。

是一个进程占有CPU资源的基本单位。

​		在单CPU的体系环境下，任何一个时刻只有一个进程在运行，但是，在一个时间段内，可以看到多个进程在运行。事实上，由于一台计算机只有一个CPU，所以永远不可能真正地同时运行多个任务。这些进程看起来像同时运行的，实则是轮番穿插地运行，由于时间片通常很短很短，所以用户不会感觉到。

上下文数据：把一个进程运行时CPU上寄存器上的数据叫做上下文数据。进程1的上下文数据存放在PCB中。进程1/进程2/进程3：叫做进程间切换。进程间切换必须要保存/恢复硬件上下文数据。

内存指针：PCB里能找到目标进程的代码和数据。

I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表。

记账信息：包括处理器时间总和，使用的时钟数总和，时间限制，记账号等。



getpid()：获取进程PID的函数  头文件：sys/types.h     unistd.h

getppid()：获取父进程PID的函数               一个进程对应的父进程的PID号是唯一的。

​                                                                        父进程是bash命令行解释器

fork：通过系统调用创建进程（通过代码创建进程，从进程中创建进程）

​	fork创建出来的子进程PCB是以父进程为模板的，父子进程代码共享，但是数据是私有的。

​        fork调用之后，有俩个进程要执行return语句。执行后，有俩个返回值，给父进程返回子进程的PID，给子进程返回0。

​        进程运行时具有独立性，体现在PCB不同、数据不同、代码不同。一个进程崩溃了不会影响别的进程。进程之间不相关，父子进程之间照样不相关。即使父子进程之间代码共享，一旦程序跑起来成为进程之后，都不能修改代码，都是只读的。

​        fork之后通常要用if分流：返回值<0，创建失败。返回值==0，子进程工作。返回值>0，父进程工作。

##### 进程状态

R：运行状态，并不意味着程序一定在运行中，它表明程序要么在运行中要么在运行队列里。

S：睡眠状态，意味着进程在等待事件完成，重点是这个进程可以被终止，可以被杀掉。

D：磁盘休眠状态（深度休眠状态），在这个状态的进程通常会等待IO的结束，不可以被中断，防止被杀掉。

Z：僵尸状态

T：停止状态

X：死亡状态

###### 僵尸进程：

当子进程退出但不会立即释放子进程的PCB，会保存一段时间，并且会一直在等待父进程读取退出码。这段时间进程是僵尸状态。

僵尸进程会以终止状态保持在进程表中。

僵尸进程危害：

父进程一直不读取，那么子进程一直处于僵尸状态。

用数据维护退出状态，也属于进程基本信息，所以也保存在task_struct中，僵尸状态一直不退出，PCB一直都要维护。

###### 孤儿进程

父进程先退出，子进程就称为“孤儿进程”。

孤儿进程被1号init进程（约等于系统）领养，当然要有inti进程（系统）回收。

##### 进程优先级

UID：代表执行者的身份

PID：代表这个进程的标识符

PPID：代表这个进程的父进程的标识符

PRI：代表这个进程的优先级，值越小越早被执行

NI：代表这个进程的nice值，表示进程可被执行的优先级的修正数值

PRI(new)=PRI(old)+nice



nice -n -5 ./test：开始执行程序就指定nice值

renice -5 -p 5200：PID为5200的进程nice设为-5

top进入后按"r"--->输入进程PID--->输入nice值：更改已存在的nice

##### 环境变量

操作系统中用来指定操作系统运行环境的一些参数。在链接的时候通常就是环境变量帮助编译器查找动态静态库。在系统当中，环境变量通常具有全局特性

PATH：用来搜索可执行程序的路径

​        bin目录下存放着可执行文件，比如bin下的ls，如果想把自己的可执行文件例如myproc放到bin目录下，可以是可以，但不推荐，容易造成系统默认命令污染。

​	可以把当前路径加到环境变量PATH中去，用冒号做分隔符。PATH=$PATH：要被可执行的路径

HOME：当前用户的主工作目录，root用户和普通用户的HOME是不一样的。

HISTSIZE：保存历史命令记录的条数。

SHELL：当前Shell，它的值通常是/bin/bash。

查看环境变量：echo $环境变量名

获取环境变量：

1. environ：系统提供的一个二级指针，就是指向环境变量表的一个指针，环境变量表就是一个个指向环境变量的指针的数组（字符指针数组），这个数组最后一个元素是空，每个指针指向一个以‘\0’结尾的环境字符串，

 2. getenv();  

    ```
    int main(int argc,char* argv[],char* env[])
    {
        printf("%s\n",getenv("PATH"));
        printf("%s\n",getenv("SHELL"));
    }
    ```

    获取PATH和SHELL环境变量的路径。

  3.putenv();

​    设置环境变量；

export MYENY="10000000000000000"

环境变量可以由父进程传给子进程

#### 程序地址空间

写时拷贝：指的是俩个任务可以同时自由读取内存，但任意一个任务试图对内存进行修改时，内存就会复制一份提供给修改方单独使用，以免影响到其他的任务使用。

内核只为新生成的子进程创建虚拟空间结构，它们复制于父进程的虚拟空间结构，但是不为这些段分配物理内存，它们共享父进程的物理空间，当父子进程中有更改相应的段的行为发生时，再为子进程相应的段分配物理空间。

系统调用：

fork：复制当前进程

exec：使用新的可执行映像覆盖当前可执行映像

clone：创建子进程并从指定位置开始执行

fork出来子进程后，父进程和子进程谁先运行？

答：用户不知道，是由系统决定的。

   I am child，pid：3275，g_val：300，&g_val：0x80497c8

I am parent，pid：3274，g_val：100，&g_val：0x80497c8

此时父子进程对应的地址相同，但这个地址绝不是真正地物理内存地址。并且对应的物理内存地址绝不相同。

我们在C/C++语言所看到的地址，全部都是虚拟地址！物理地址，用户一般看不到，由操作系统（OS）统一管理。

虚拟地址空间：

父子进程如何做到代码共享？

答：父进程通过页表访问物理内存地址上的代码，子进程也通过页表访问物理内存上的代码

虚拟地址空间的作用：

1.让每个进程拥有了相同、独立内存空间，相互之间不会干扰。

2.读写内存更安全。由于系统和MMU的限制，使得进程无法操作到其他进程的数据。

3.不连续的物理空间可以映射成连续的虚拟地址空间。

4.进程分配的内存空间只有在实际使用时，才会触发缺页异常来分配实际物理空间，从而最大程度减少了内存空间的浪费。



共享的本质：不同的进程取地址通过页表映射到相同的物理内存。

私有的本质：不同的进程取地址通过页表映射到不同的物理内存。

##### 内核进程调度队列：

linux内核2.6所采用的调度算法的时间复杂度是O（1）；