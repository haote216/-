##### 类：

```
C语言中struct结构体中只能定义变量，不能定义函数。
C++中class类可以定义函数。  
在C语言中，struct定义类，类型：struct ListNode
在C++中 struct升级成类，类型：ListNode
面试题：struct和class的区别？
答：struct在C语言阶段就是一个结构体，而struct在C++中兼容C语言中结构体这个功能，同时还有定义类的功能，而class在C++是一个定义类的功能。struct和class在C++中作为类这个角度区别是：在访问限定符上，struct默认是公有，class默认是私有。
```

##### 类对象模型：

```
类中的成员变量都是声明，没有任何内存上的存储。只有定义出来类的对象时，类的成员变量才分配了内存。
类的成员变量是独立的，类的成员函数是共享的。
一个类的大小，就是该类中“成员变量”之和，当然也要进行内存对齐。
没有成员变量的类/空类占1个字节单位，不存数据，占位，表示对象存在过。
```

###### 结构体内存对齐规则：

```
1.第一个成员在与结构体偏移量为0的地址处。
2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
  注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
  VS中默认的对齐数为8，gcc中的对齐数为4
3.结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。
4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是
所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
```

###### 面试题：

```
1.为什么要进行内存对齐？
答：平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的，某些硬件平台只能在某些地址处取某些特定类型的数据，否则会抛出硬件异常。
   性能原因：内存对齐是以空间换时间的行为，内存读取每次都是按整数倍的形式读取，所以没有进行内存对齐的内存读取效率太低。经过内存对齐后，CPU的内存访问速度大大提升，cpu访问内存就是读取字节数的整数倍
2.如何让结构体按照指定的对齐参数进行对齐？
答：使用# pragma pack()或者按Alt+f7 自行去编译器设置
3.如何知道结构体中某个成员相对于结构体起始位置的偏移量？
答： printf("%d\n",offsetof(A, c));  offsetof，该宏用于求结构体中一个成员在结构体中的偏移量。
4.什么是大小端？如何测试某台机器是大端还是小端，有没有遇到过要考虑大小端的场景？
小端：低位字节序的内容放在低地址处，高位字节序内容放在高地址处
大端：低位字节序的内容放在高地址处，高位字节序内容放在低地址处
```

##### 访问限定符：

```
public修饰的成员在类外可以直接被访问。
protected和private修饰的成员在类外不能直接被访问。
struct的默认访问权限为public，class的默认访问权限为private。
```

#### this指针：

```
c++编译器给每个成员函数增加了一个隐藏的指针参数，让该指针指向当前对象（函数运行时调用该函数的对象），在函数体重所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即不需要来传递，编译器自动完成。
面试题：this指针存在哪儿？可以为空吗？
答：属于形参，一般是存在栈上的。在windows的VS下，是放在ecx中，由ecx寄存器传递的。可以是空，只要不访问类定义的成员变量就OK，但是访问类中的成员变量代码就会崩掉。
```

**特性：**

```
1.this指针的类型：类类型*const
2.只能在成员函数的内部使用
3.this指针本质上起始是一个成员函数的形参，是对象调用成员函数，将对象地址作为实参传递给this形参。所以对象中不储存this指针。
```