##### 命名空间：

``` 
printf("%d\n",a);         //访问最近定义的a
printf("%d\n",::a);       //访问全局域的a
printf("%d\n",my::a);     //访问my这个命名空间的a
printf("%d\n",your::a);   //访问your这个命名空间的a
using namespace std;   //std  C++库的命名空间
```

##### 缺省参数：

```
缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。
半缺省参数必须从右往左依次给出，不能间隔着给。
缺省参数不能在函数声明和定义中同时出现，那么编译器就无法确定到底该用哪个缺省值。
```

##### 函数重载：

```
这些同名函数的形参列表（参数个数 或 参数类型 或 顺序）必须不同，和返回值类型无关。
为什么C语言不支持函数重载，而C++支持函数重载？
C语言的名字修饰规则非常简单，只是在函数名字前面添加了下划线。
C++修饰规则，被重新修饰的名字中包含了：函数名字和参数类型，这样就保证了名字在底层的全局唯一性
```

### 引用：

```
给变量取一个别名，不会为引用开辟新的内存空间，它和它引用的变量共用同一块内存空间。
类型 & 引用变量名=引用实体
int & ra =a;            

引用类型必须和引用实体是同种类型。
引用在定义时必须初始化。
一个变量可以有多个引用。
引用一旦引用一个实体，再不能引用其他实体。

引用的使用场景：
1.做参数
2.做返回值
   做返回值时，传引用能够不用再去开辟一块新的内存空间，如果返回一个结构体或者特别大的空间时，比较节约内存。
   
   做返回值时，离开函数作用域后，其栈上空间已经返回到系统，因此不能用栈上的空间作为引用类型返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制（即比函数生命周期长）。
   
```

##### 常引用：

```
const int a=10;
      int &ra=a;     （错误）a为常量，不能被修改
const int& ra=a;     （正确）必须加const，a为常量。

      int &b=10；    （错误）
const int &b=10;     （正确）  

      int c = 20；
const int &d = c；    （正确）都不能被修改
  
     int  e = 20;
    double f = e;     (正确)发生了隐式类型的转化，是相近类型。e把数据给临时变量，临时变量                             把数据再给f，而临时变量具有常性
   double& f = e;     (错误）
const double& f = e; （正确）这里的f不是e的别名，而是那个临时变量的别名
```

#### 引用和指针的区别（重点）：

```
1.引用在定义时必须初始化，指针没有要求
2.引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体。
3.没有NULL引用，但有NULL指针。
4.在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数（32位平台下占4个字节）。
5.引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。
6.有多级指针，但是没有多级引用。
7.访问实体方式不同，指针需要显式解引用，引用编译器自己处理。
8.引用比指针使用起来相对更安全。
```

```
在性能上，传指针和传引用的效率几乎相同。

在语法层面上，引用就是个别名，没有独立空间。
在底层实现上，引用实际是有空间的，因为引用是按照指针方式来实现的。
```

#### 内联函数

```
以inline修饰的函数叫做内联函数，编译时C++编译器在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。

1.内联是一种以空间换时间的做法，省去调用函数额外开销。所以代码很长或者有循环/递归的函数不适宜使用作为内联函数。
2.inline对编译器而言只是一个建议，编译器会自动优化，编译器也可以会忽略掉内联。
3.inline不建议声明和定义分离，分离会导致链接错误。因为linline会展开，就没有函数地址了，链接就会找不到。
```

面试题：宏的优缺点

```
宏：
优点：1.增强代码的复用性
     2.提高性能
缺点：1.不方便调试
     2.导致代码可维护性差、可读性差
     3.没有类型安全的检查，不安全
     
C++用const替换宏常量
   用内联函数替换宏函数
```

##### auto关键字（C++11)

```
auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得。
int a = 10;
auto b = a;   //整型
auto c = 'a'; //字符型
auto e；      //无法通过编译，使用auto定义变量时必须对其进行初始化
auto并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变
量实际的类型。
用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时则必须加&。
当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量。
auto不能推导的场景：
1.auto不能作为函数的参数
2.auto不能直接用来声明数组
3.auto不能定义类的非静态成员变量
4.实例化模板时不能使用auto作为模板参数
5.为了避免与C++98中的auto发生混淆，C++11只保留了auto作为类型指示符的用法
6.auto在实际中最常见的优势用法就是跟以后会讲到的C++11提供的新式for循环，还有lambda表达式等进行配合使用
```

##### 基于范围的for循环（C++11）

```
for循环后的括号由冒号“ ：”分为两部分：第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围。
```

##### 指针空值nullptr(C++11)

```
nullptr代表一个指针空值常量，nullptr是有类型的，其类型为nullptr_t，仅仅可以被隐式转化为指针类型
typedef decltype(nullptr) nullptr_t;
注意：
1. 在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。
2. 在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。
3. 为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr。
```

