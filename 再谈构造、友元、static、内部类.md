##### 再谈构造

初始化列表：以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个"成员变量"后面跟一个放在括号中的初始值或表达式。

类中包含以下成员，必须放在初始化列表位置进行初始化：引用成员变量、const成员变量、类类型成员（该类没有默认构造函数）

成员变量在类中声明次序就是在初始化列表中的初始化顺序，与其在初始化列表的先后次序无关。

###### explicit:

首先, C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式)

 explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。

##### C++11的成员初始化新玩法

C++11支持非静态成员变量在声明时，直接初始化。

##### 友元

友元提供了一种突破封装的方式，提供了便利。但是友元会增加耦合度，破坏了封装，所以友元不宜多用。

###### 友元函数

友元函数可以访问类的私有成员，但不是类的成员函数，不带this指针，必须通过对象名或者对象的引用作为友元函数的参数来访问对象的成员。

友元函数不能用const修饰。

###### 友元类

##### static成员

C语言中static作用：

1.静态局部变量：static用于函数体内部修饰变量，这种变量的生存期长于该函数。也就是说，static修饰的局部变量随着第一次函数的调用而初始化，却不随着函数的调用结束而销毁。它是在第一次调用就初始化，后面调用的时候就不再初始化了，而会直接跳过。

​	1）该变量在全局数据区分配内存，全局数据区的默认初始化为0。static的一个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’。（局部变量是在栈区分配内存）

​	2）静态局部变量是在程序执行到该对象的声明处时被首次初始化，以后的函数调用不再进行初始化（局部变量每次函数调用都会被初始化）

​	3）静态局部变量一般是在声明处初始化，如果没有显式初始化，会被程序自动初始化为0。（局部比变量不会被初始化）

​	4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它（局部变量在栈区，在函数结束后立即释放内存）

2.静态全局变量：定义在函数体外，用于修饰全局变量，表示该变量只在本文件中可见。

静态全局变量不能被其他文件所用（全局变量可以）；其他文件中可以定义相同名字的变量，不会发生冲突（自然了，因为static隔离了文件，其他文件使用相同名字的变量也跟它没关系了）

3.静态函数：静态函数和静态全局变量的作用类似，一个是修饰变量，一个是修饰函数。

C++中static俩种作用

1.静态成员变量：用于修饰数据成员，也叫静态成员。这种数据成员的生存期大于class的对象。静态成员变量是每个类只有一份，而普通成员变量是每个对象就有一份。因此静态数据成员也叫类变量，而普通成员变量也叫做实例变量。

用sizeof求类对象的大小，发现static修饰的成员变量并不占内存空间。那么static在哪分配内存呢？

是的，全局数据区（静态区）。

对于非静态成员变量，每个类对象都有自己的拷贝。而静态成员变量被当做是类的成员，由该类型的所有对象共享访问，对该类的多个对象来说，静态成员变量只分配一次内存。静态成员变量存储在全局数据区。静态成员变量定义时要分配空间，所以补鞥呢在类声明中定义。

2.静态成员函数：

​	1）静态成员之间可以相互访问，包括静态成员函数访问静态成员变量和静态成员函数。

​	2）非静态成员函数可以任意的访问静态成员变量和静态成员函数。

​	3）静态成员函数不能访问非静态成员变量和非静态成员函数。

​	4）调用静态成员函数，可以用成员访问操作符.   ->，也可以用：：

面试题：

1.静态成员函数可以调用非静态成员函数吗？      不可以

2.非静态成员函数可以调用类的静态成员函数吗？  可以

##### 内部类

##### 再次理解封装类