2018.12.5笔记：

1.按位与 &： 0 & 0 = 0；0 & 1 = 0；1 & 0 = 0；1 & 1 =1；（俩位同为1时，结果才为1）

   按位或 |： 0 | 0 =0；0 | 1 =1；1 | 0 = 1；1 | 1 =1；（俩位中只要有1位为1，结果就为1）

   按位异或 ^ : 0 ^ 0 =0;0 ^ 1 =1; 1 ^ 0 = 1; 1 ^ 1 = 0;(俩位相同为0，相异为1)

注：以上操作符均是以二进制进行操作的。负数均是以补码的形式进行的。

2.sizeof里面的表达式不进行运算，但是求的是可能的取值的字节大小。

3.常见寄存器：esp,ebp,eax,ebx,ecx,edx

4.我们写的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的，计算路径一定要唯一。



5. ​      sizeof(数组名)       &(数组名)    这俩个数组名代表的是整个数组，其余的情况数组名都表示首元素的地址。

```c
int arr[10]={0};
arr              //首元素的地址
arr+1            //首元素的地址
sizeof(*arr)     //4
    
&arr[0]          //首元素的地址
&arr[0]+1        //首元素的地址
sizeof(*&arr[0]) //4
    
&arr            //数组的地址
&arr+1          //数组的地址
sizeof(*&arr)   // 40
    
```

6.随着数组下标的增大地址是由低到高的

7.

```
比特位置1：value = value | 1<<bit_number;
比特位清0：value = value & ~(1<<bit_number);
```

8.\是C语言的转义字符的起始标识。

当\后面直接跟数字的时候，会被处理成对应的8进制。

\377就是8进制377对应的ascii值，二进制位11 111 111，也就是16进制的0xff，10进制为255。

9.一个小的内存单元是1字节。（8个比特位）

10.在函数内部开辟一块数组空间，a[0]到a[9]，随着下标的增加，地址也是依次增大。

这不是依次入栈，先入栈的a[0]地址大，后入栈的地址小。而是数组是一种类型，开辟的时候，一次性的把所有数组空间给你，然后a[0]在最下面，a[9]在最上面。

11.整形是4个字节，每次开辟的时候，地址是最小的地址，数组亦是。

12.每次调用函数，形成栈帧。函数返回，释放栈帧。

理论上一个函数一个栈帧。

调用函数，形成栈帧，开辟空间，花费时间，花费内存。如果不断调用函数，不断花时间花内存，所以递归的开销大的多。所以，递归必须有出口，否则栈溢出。