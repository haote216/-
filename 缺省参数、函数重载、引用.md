##### 命名空间：

``` 
printf("%d\n",a);         //访问最近定义的a
printf("%d\n",::a);       //访问全局域的a
printf("%d\n",my::a);     //访问my这个命名空间的a
printf("%d\n",your::a);   //访问your这个命名空间的a
using namespace std;   //std  C++库的命名空间
```

##### 缺省参数：

```
缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。
半缺省参数必须从右往左依次给出，不能间隔着给。
缺省参数不能在函数声明和定义中同时出现，那么编译器就无法确定到底该用哪个缺省值。
```

##### 函数重载：

```
这些同名函数的形参列表（参数个数 或 参数类型 或 顺序）必须不同，和返回值类型无关。
为什么C语言不支持函数重载，而C++支持函数重载？
C语言的名字修饰规则非常简单，只是在函数名字前面添加了下划线。
C++修饰规则，被重新修饰的名字中包含了：函数名字和参数类型，这样就保证了名字在底层的全局唯一性
```

### 引用：

```
给变量取一个别名，不会为引用开辟新的内存空间，它和它引用的变量共用同一块内存空间。
类型 & 引用变量名=引用实体
int & ra =a;            

引用类型必须和引用实体是同种类型。
一个变量可以有多个引用。
引用一旦引用一个实体，再不能引用其他实体。

引用的使用场景：
1.做参数
2.做返回值
   做返回值时，离开函数作用域后，其栈上空间已经返回到系统，因此不能用栈上的空间作为引用类型返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制（即比函数生命周期长）。
```

##### 常引用：

```
const int a=10;
const int& ra=a;       必须加const，a为常量。

//int &b=10；       （错误）
  const int &b=10;  （正确）    

double d =12.34;
//int &rd = d;        （错误）
 const int &rd = d;   （正确）
```



##### 引用和指针的区别：

```
1.引用在定义时必须初始化，指针没有要求

2.引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体。

3.没有NULL引用，但有NULL指针。

4.在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数（32位平台下占4个字节）。

5.引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小。

6.有多级指针，但是没有多级引用。

7.访问实体方式不同，指针需要显式解引用，引用编译器自己处理。

8.引用比指针使用起来相对更安全。
```

##### 传值、传引用效率比较：

